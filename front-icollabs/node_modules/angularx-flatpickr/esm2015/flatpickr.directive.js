/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Directive, ElementRef, Input, Output, EventEmitter, forwardRef, HostListener, Renderer2 } from '@angular/core';
import { FlatpickrDefaults } from './flatpickr-defaults.service';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import flatpickr from 'flatpickr';
/**
 * @record
 */
export function FlatPickrOutputOptions() { }
function FlatPickrOutputOptions_tsickle_Closure_declarations() {
    /** @type {?} */
    FlatPickrOutputOptions.prototype.selectedDates;
    /** @type {?} */
    FlatPickrOutputOptions.prototype.dateString;
    /** @type {?} */
    FlatPickrOutputOptions.prototype.instance;
}
/**
 * @record
 */
export function FlatPickrDayCreateOutputOptions() { }
function FlatPickrDayCreateOutputOptions_tsickle_Closure_declarations() {
    /** @type {?} */
    FlatPickrDayCreateOutputOptions.prototype.dayElement;
}
export const /** @type {?} */ FLATPICKR_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => FlatpickrDirective),
    //tslint:disable-line
    multi: true
};
export class FlatpickrDirective {
    /**
     * @param {?} elm
     * @param {?} defaults
     * @param {?} renderer
     */
    constructor(elm, defaults, renderer) {
        this.elm = elm;
        this.defaults = defaults;
        this.renderer = renderer;
        /**
         * Gets triggered once the calendar is in a ready state
         */
        this.flatpickrReady = new EventEmitter();
        /**
         * Gets triggered when the user selects a date, or changes the time on a selected date.
         */
        this.flatpickrChange = new EventEmitter();
        /**
         * Gets triggered when the input value is updated with a new date string.
         */
        this.flatpickrValueUpdate = new EventEmitter();
        /**
         * Gets triggered when the calendar is opened.
         */
        this.flatpickrOpen = new EventEmitter();
        /**
         * Gets triggered when the calendar is closed.
         */
        this.flatpickrClose = new EventEmitter();
        /**
         * Gets triggered when the month is changed, either by the user or programmatically.
         */
        this.flatpickrMonthChange = new EventEmitter();
        /**
         * Gets triggered when the year is changed, either by the user or programmatically.
         */
        this.flatpickrYearChange = new EventEmitter();
        /**
         * Take full control of every date cell with this output
         */
        this.flatpickrDayCreate = new EventEmitter();
        this.isDisabled = false;
        this.onChangeFn = () => { };
        this.onTouchedFn = () => { };
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        const /** @type {?} */ options = {
            altFormat: this.altFormat,
            altInput: this.altInput,
            altInputClass: this.altInputClass,
            allowInput: this.allowInput,
            appendTo: this.appendTo,
            ariaDateFormat: this.ariaDateFormat,
            clickOpens: this.clickOpens,
            dateFormat: this.dateFormat,
            defaultHour: this.defaultHour,
            defaultMinute: this.defaultMinute,
            defaultSeconds: this.defaultSeconds,
            disable: this.disable,
            disableMobile: this.disableMobile,
            enable: this.enable,
            enableTime: this.enableTime,
            enableSeconds: this.enableSeconds,
            formatDate: this.formatDate,
            hourIncrement: this.hourIncrement,
            defaultDate: this.initialValue,
            inline: this.inline,
            maxDate: this.maxDate,
            minDate: this.minDate,
            minuteIncrement: this.minuteIncrement,
            mode: this.mode,
            nextArrow: this.nextArrow,
            noCalendar: this.noCalendar,
            now: this.now,
            parseDate: this.parseDate,
            prevArrow: this.prevArrow,
            shorthandCurrentMonth: this.shorthandCurrentMonth,
            showMonths: this.showMonths,
            static: this.static,
            time24hr: this.time24hr,
            weekNumbers: this.weekNumbers,
            getWeek: this.getWeek,
            wrap: this.wrap,
            plugins: this.plugins,
            locale: this.locale,
            onChange: (selectedDates, dateString, instance) => {
                this.flatpickrChange.emit({ selectedDates, dateString, instance });
            },
            onOpen: (selectedDates, dateString, instance) => {
                this.flatpickrOpen.emit({ selectedDates, dateString, instance });
            },
            onClose: (selectedDates, dateString, instance) => {
                this.flatpickrClose.emit({ selectedDates, dateString, instance });
            },
            onMonthChange: (selectedDates, dateString, instance) => {
                this.flatpickrMonthChange.emit({ selectedDates, dateString, instance });
            },
            onYearChange: (selectedDates, dateString, instance) => {
                this.flatpickrYearChange.emit({ selectedDates, dateString, instance });
            },
            onReady: (selectedDates, dateString, instance) => {
                this.flatpickrReady.emit({ selectedDates, dateString, instance });
            },
            onValueUpdate: (selectedDates, dateString, instance) => {
                this.flatpickrValueUpdate.emit({ selectedDates, dateString, instance });
            },
            onDayCreate: (selectedDates, dateString, instance, dayElement) => {
                this.flatpickrDayCreate.emit({
                    selectedDates,
                    dateString,
                    instance,
                    dayElement
                });
            }
        };
        Object.keys(options).forEach(key => {
            if (typeof options[key] === 'undefined') {
                options[key] = (/** @type {?} */ (this.defaults))[key];
            }
        });
        options.time_24hr = options.time24hr;
        this.instance = /** @type {?} */ (flatpickr(this.elm.nativeElement, options));
        this.setDisabledState(this.isDisabled);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.instance) {
            Object.keys(changes).forEach(inputKey => {
                this.instance.set(/** @type {?} */ (inputKey), (/** @type {?} */ (this))[inputKey]);
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.instance.destroy();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        let /** @type {?} */ convertedValue = value;
        if (this.convertModelValue && this.mode === 'range' && value) {
            convertedValue = [value.from, value.to];
        }
        if (this.instance) {
            this.instance.setDate(convertedValue);
        }
        else {
            // flatpickr hasn't been initialised yet, store the value for later use
            this.initialValue = convertedValue;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeFn = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedFn = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.isDisabled = isDisabled;
        if (this.instance) {
            if (this.isDisabled) {
                this.renderer.setProperty(this.instance._input, 'disabled', 'disabled');
            }
            else {
                this.renderer.removeAttribute(this.instance._input, 'disabled');
            }
        }
    }
    /**
     * @return {?}
     */
    inputChanged() {
        const /** @type {?} */ value = this.elm.nativeElement.value;
        if (this.convertModelValue && typeof value === 'string') {
            switch (this.mode) {
                case 'multiple':
                    const /** @type {?} */ dates = value
                        .split('; ')
                        .map(str => this.instance.parseDate(str, this.instance.config.dateFormat, !this.instance.config.enableTime));
                    this.onChangeFn(dates);
                    break;
                case 'range':
                    const [from, to] = value
                        .split(this.instance.l10n.rangeSeparator)
                        .map(str => this.instance.parseDate(str, this.instance.config.dateFormat, !this.instance.config.enableTime));
                    this.onChangeFn({ from, to });
                    break;
                case 'single':
                default:
                    this.onChangeFn(this.instance.parseDate(value, this.instance.config.dateFormat, !this.instance.config.enableTime));
            }
        }
        else {
            this.onChangeFn(value);
        }
    }
}
FlatpickrDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mwlFlatpickr]',
                providers: [FLATPICKR_CONTROL_VALUE_ACCESSOR],
                host: {
                    // tslint:disable-line use-host-property-decorator
                    '(blur)': 'onTouchedFn()'
                }
            },] },
];
/** @nocollapse */
FlatpickrDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: FlatpickrDefaults },
    { type: Renderer2 }
];
FlatpickrDirective.propDecorators = {
    altFormat: [{ type: Input }],
    altInput: [{ type: Input }],
    altInputClass: [{ type: Input }],
    allowInput: [{ type: Input }],
    appendTo: [{ type: Input }],
    ariaDateFormat: [{ type: Input }],
    clickOpens: [{ type: Input }],
    dateFormat: [{ type: Input }],
    defaultHour: [{ type: Input }],
    defaultMinute: [{ type: Input }],
    defaultSeconds: [{ type: Input }],
    disable: [{ type: Input }],
    disableMobile: [{ type: Input }],
    enable: [{ type: Input }],
    enableTime: [{ type: Input }],
    enableSeconds: [{ type: Input }],
    formatDate: [{ type: Input }],
    hourIncrement: [{ type: Input }],
    inline: [{ type: Input }],
    maxDate: [{ type: Input }],
    minDate: [{ type: Input }],
    minuteIncrement: [{ type: Input }],
    mode: [{ type: Input }],
    nextArrow: [{ type: Input }],
    noCalendar: [{ type: Input }],
    now: [{ type: Input }],
    parseDate: [{ type: Input }],
    prevArrow: [{ type: Input }],
    shorthandCurrentMonth: [{ type: Input }],
    showMonths: [{ type: Input }],
    static: [{ type: Input }],
    time24hr: [{ type: Input }],
    weekNumbers: [{ type: Input }],
    getWeek: [{ type: Input }],
    wrap: [{ type: Input }],
    plugins: [{ type: Input }],
    locale: [{ type: Input }],
    convertModelValue: [{ type: Input }],
    flatpickrReady: [{ type: Output }],
    flatpickrChange: [{ type: Output }],
    flatpickrValueUpdate: [{ type: Output }],
    flatpickrOpen: [{ type: Output }],
    flatpickrClose: [{ type: Output }],
    flatpickrMonthChange: [{ type: Output }],
    flatpickrYearChange: [{ type: Output }],
    flatpickrDayCreate: [{ type: Output }],
    inputChanged: [{ type: HostListener, args: ['input',] }]
};
function FlatpickrDirective_tsickle_Closure_declarations() {
    /**
     * Exactly the same as date format, but for the altInput field.
     * @type {?}
     */
    FlatpickrDirective.prototype.altFormat;
    /**
     * 	Show the user a readable date (as per altFormat), but return something totally different to the server.
     * @type {?}
     */
    FlatpickrDirective.prototype.altInput;
    /**
     * This class will be added to the input element created by the altInput option.
     * Note that `altInput` already inherits classes from the original input.
     * @type {?}
     */
    FlatpickrDirective.prototype.altInputClass;
    /**
     * Allows the user to enter a date directly input the input field. By default, direct entry is disabled.
     * @type {?}
     */
    FlatpickrDirective.prototype.allowInput;
    /**
     * Instead of `body`, appends the calendar to the specified node instead.
     * @type {?}
     */
    FlatpickrDirective.prototype.appendTo;
    /**
     * Defines how the date will be formatted in the aria-label for calendar days, using the same tokens as dateFormat. If you change this, you should choose a value that will make sense if a screen reader reads it out loud.
     * @type {?}
     */
    FlatpickrDirective.prototype.ariaDateFormat;
    /**
     * Whether clicking on the input should open the picker.
     * You could disable this if you wish to open the calendar manually `with.open()`.
     * @type {?}
     */
    FlatpickrDirective.prototype.clickOpens;
    /**
     * A string of characters which are used to define how the date will be displayed in the input box.
     * The supported characters are defined in the table below.
     * @type {?}
     */
    FlatpickrDirective.prototype.dateFormat;
    /**
     * Initial value of the hour element.
     * @type {?}
     */
    FlatpickrDirective.prototype.defaultHour;
    /**
     * Initial value of the minute element.
     * @type {?}
     */
    FlatpickrDirective.prototype.defaultMinute;
    /**
     * Initial value of the seconds element.
     * @type {?}
     */
    FlatpickrDirective.prototype.defaultSeconds;
    /**
     * See <a href="https://chmln.github.io/flatpickr/examples/#disabling-specific-dates">disabling dates</a>.
     * @type {?}
     */
    FlatpickrDirective.prototype.disable;
    /**
     * Set disableMobile to true to always use the non-native picker.
     * By default, Flatpickr utilizes native datetime widgets unless certain options (e.g. disable) are used.
     * @type {?}
     */
    FlatpickrDirective.prototype.disableMobile;
    /**
     * See <a href="https://chmln.github.io/flatpickr/examples/#disabling-all-dates-except-select-few">enabling dates</a>.
     * @type {?}
     */
    FlatpickrDirective.prototype.enable;
    /**
     * Enables time picker.
     * @type {?}
     */
    FlatpickrDirective.prototype.enableTime;
    /**
     * Enables seconds in the time picker.
     * @type {?}
     */
    FlatpickrDirective.prototype.enableSeconds;
    /**
     * Allows using a custom date formatting function instead of the built-in handling for date formats using dateFormat, altFormat, etc.
     * @type {?}
     */
    FlatpickrDirective.prototype.formatDate;
    /**
     * Adjusts the step for the hour input (incl. scrolling).
     * @type {?}
     */
    FlatpickrDirective.prototype.hourIncrement;
    /**
     * Displays the calendar inline.
     * @type {?}
     */
    FlatpickrDirective.prototype.inline;
    /**
     * The maximum date that a user can pick to (inclusive).
     * @type {?}
     */
    FlatpickrDirective.prototype.maxDate;
    /**
     * The minimum date that a user can start picking from (inclusive).
     * @type {?}
     */
    FlatpickrDirective.prototype.minDate;
    /**
     * Adjusts the step for the minute input (incl. scrolling).
     * @type {?}
     */
    FlatpickrDirective.prototype.minuteIncrement;
    /**
     * Select a single date, multiple dates or a date range.
     * @type {?}
     */
    FlatpickrDirective.prototype.mode;
    /**
     * HTML for the arrow icon, used to switch months.
     * @type {?}
     */
    FlatpickrDirective.prototype.nextArrow;
    /**
     * Hides the day selection in calendar. Use it along with `enableTime` to create a time picker.
     * @type {?}
     */
    FlatpickrDirective.prototype.noCalendar;
    /**
     * Provide a date for 'today', which will be used instead of "new Date()"
     * @type {?}
     */
    FlatpickrDirective.prototype.now;
    /**
     * Function that expects a date string and must return a Date object.
     * @type {?}
     */
    FlatpickrDirective.prototype.parseDate;
    /**
     * HTML for the left arrow icon.
     * @type {?}
     */
    FlatpickrDirective.prototype.prevArrow;
    /**
     * Show the month using the shorthand version (ie, Sep instead of September).
     * @type {?}
     */
    FlatpickrDirective.prototype.shorthandCurrentMonth;
    /**
     * The number of months shown.
     * @type {?}
     */
    FlatpickrDirective.prototype.showMonths;
    /**
     * Position the calendar inside the wrapper and next to the input element. (Leave `false` unless you know what you're doing).
     * @type {?}
     */
    FlatpickrDirective.prototype.static;
    /**
     * Displays time picker in 24 hour mode without AM/PM selection when enabled.
     * @type {?}
     */
    FlatpickrDirective.prototype.time24hr;
    /**
     * Enables display of week numbers in calendar.
     * @type {?}
     */
    FlatpickrDirective.prototype.weekNumbers;
    /**
     * You may override the function that extracts the week numbers from a Date by supplying a getWeek function.
     * It takes in a date as a parameter and should return a corresponding string that you want to appear left of every week.
     * @type {?}
     */
    FlatpickrDirective.prototype.getWeek;
    /**
     * Custom elements and input groups.
     * @type {?}
     */
    FlatpickrDirective.prototype.wrap;
    /**
     * Array of plugin instances to use.
     * @type {?}
     */
    FlatpickrDirective.prototype.plugins;
    /**
     * The locale object or string to use for the locale.
     * @type {?}
     */
    FlatpickrDirective.prototype.locale;
    /**
     * Auto convert the ngModel value from a string to a date / array of dates / from - to date object depending on the `mode`
     * @type {?}
     */
    FlatpickrDirective.prototype.convertModelValue;
    /**
     * Gets triggered once the calendar is in a ready state
     * @type {?}
     */
    FlatpickrDirective.prototype.flatpickrReady;
    /**
     * Gets triggered when the user selects a date, or changes the time on a selected date.
     * @type {?}
     */
    FlatpickrDirective.prototype.flatpickrChange;
    /**
     * Gets triggered when the input value is updated with a new date string.
     * @type {?}
     */
    FlatpickrDirective.prototype.flatpickrValueUpdate;
    /**
     * Gets triggered when the calendar is opened.
     * @type {?}
     */
    FlatpickrDirective.prototype.flatpickrOpen;
    /**
     * Gets triggered when the calendar is closed.
     * @type {?}
     */
    FlatpickrDirective.prototype.flatpickrClose;
    /**
     * Gets triggered when the month is changed, either by the user or programmatically.
     * @type {?}
     */
    FlatpickrDirective.prototype.flatpickrMonthChange;
    /**
     * Gets triggered when the year is changed, either by the user or programmatically.
     * @type {?}
     */
    FlatpickrDirective.prototype.flatpickrYearChange;
    /**
     * Take full control of every date cell with this output
     * @type {?}
     */
    FlatpickrDirective.prototype.flatpickrDayCreate;
    /** @type {?} */
    FlatpickrDirective.prototype.instance;
    /** @type {?} */
    FlatpickrDirective.prototype.isDisabled;
    /** @type {?} */
    FlatpickrDirective.prototype.initialValue;
    /** @type {?} */
    FlatpickrDirective.prototype.onChangeFn;
    /** @type {?} */
    FlatpickrDirective.prototype.onTouchedFn;
    /** @type {?} */
    FlatpickrDirective.prototype.elm;
    /** @type {?} */
    FlatpickrDirective.prototype.defaults;
    /** @type {?} */
    FlatpickrDirective.prototype.renderer;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxhdHBpY2tyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXJ4LWZsYXRwaWNrci8iLCJzb3VyY2VzIjpbImZsYXRwaWNrci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsVUFBVSxFQUVWLEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUlaLFVBQVUsRUFDVixZQUFZLEVBQ1osU0FBUyxFQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFDTCxpQkFBaUIsRUFFbEIsTUFBTSw4QkFBOEIsQ0FBQztBQUN0QyxPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDekUsT0FBTyxTQUFTLE1BQU0sV0FBVyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFhbEMsTUFBTSxDQUFDLHVCQUFNLGdDQUFnQyxHQUFRO0lBQ25ELE9BQU8sRUFBRSxpQkFBaUI7SUFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQzs7SUFDakQsS0FBSyxFQUFFLElBQUk7Q0FDWixDQUFDO0FBVUYsTUFBTTs7Ozs7O0lBb1FKLFlBQ1UsS0FDQSxVQUNBO1FBRkEsUUFBRyxHQUFILEdBQUc7UUFDSCxhQUFRLEdBQVIsUUFBUTtRQUNSLGFBQVEsR0FBUixRQUFROzs7OzhCQS9EcUMsSUFBSSxZQUFZLEVBQUU7Ozs7K0JBTWpCLElBQUksWUFBWSxFQUFFOzs7O29DQVF0RSxJQUFJLFlBQVksRUFBRTs7Ozs2QkFNZ0MsSUFBSSxZQUFZLEVBQUU7Ozs7OEJBTWpCLElBQUksWUFBWSxFQUFFOzs7O29DQVFyRSxJQUFJLFlBQVksRUFBRTs7OzttQ0FRbEIsSUFBSSxZQUFZLEVBQUU7Ozs7a0NBUWxCLElBQUksWUFBWSxFQUFFOzBCQUdELEtBQUs7MEJBR1MsR0FBRyxFQUFFLElBQUc7MkJBRTdCLEdBQUcsRUFBRSxJQUFHO0tBTWxC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LEtBQUs7dUJBS0wsS0FBSzs0QkFNTCxLQUFLO3lCQUtMLEtBQUs7dUJBS0wsS0FBSzs2QkFLTCxLQUFLO3lCQU1MLEtBQUs7eUJBTUwsS0FBSzswQkFLTCxLQUFLOzRCQUlMLEtBQUs7NkJBS0wsS0FBSztzQkFLTCxLQUFLOzRCQU1MLEtBQUs7cUJBS0wsS0FBSzt5QkFLTCxLQUFLOzRCQUtMLEtBQUs7eUJBS0wsS0FBSzs0QkFLTCxLQUFLO3FCQUtMLEtBQUs7c0JBS0wsS0FBSztzQkFLTCxLQUFLOzhCQUtMLEtBQUs7bUJBS0wsS0FBSzt3QkFLTCxLQUFLO3lCQUtMLEtBQUs7a0JBS0wsS0FBSzt3QkFLTCxLQUFLO3dCQUtMLEtBQUs7b0NBS0wsS0FBSzt5QkFLTCxLQUFLO3FCQUtMLEtBQUs7dUJBS0wsS0FBSzswQkFLTCxLQUFLO3NCQU1MLEtBQUs7bUJBS0wsS0FBSztzQkFLTCxLQUFLO3FCQUtMLEtBQUs7Z0NBS0wsS0FBSzs2QkFLTCxNQUFNOzhCQU1OLE1BQU07bUNBTU4sTUFBTTs0QkFRTixNQUFNOzZCQU1OLE1BQU07bUNBTU4sTUFBTTtrQ0FRTixNQUFNO2lDQVFOLE1BQU07MkJBcUtOLFlBQVksU0FBQyxPQUFPIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBBZnRlclZpZXdJbml0LFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBFdmVudEVtaXR0ZXIsXG4gIE9uQ2hhbmdlcyxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBmb3J3YXJkUmVmLFxuICBIb3N0TGlzdGVuZXIsXG4gIFJlbmRlcmVyMlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIEZsYXRwaWNrckRlZmF1bHRzLFxuICBEaXNhYmxlRW5hYmxlRGF0ZVxufSBmcm9tICcuL2ZsYXRwaWNrci1kZWZhdWx0cy5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCBmbGF0cGlja3IgZnJvbSAnZmxhdHBpY2tyJztcblxuZXhwb3J0IGludGVyZmFjZSBGbGF0UGlja3JPdXRwdXRPcHRpb25zIHtcbiAgc2VsZWN0ZWREYXRlczogRGF0ZVtdO1xuICBkYXRlU3RyaW5nOiBzdHJpbmc7XG4gIGluc3RhbmNlOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmxhdFBpY2tyRGF5Q3JlYXRlT3V0cHV0T3B0aW9uc1xuICBleHRlbmRzIEZsYXRQaWNrck91dHB1dE9wdGlvbnMge1xuICBkYXlFbGVtZW50OiBIVE1MRWxlbWVudDtcbn1cblxuZXhwb3J0IGNvbnN0IEZMQVRQSUNLUl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBGbGF0cGlja3JEaXJlY3RpdmUpLCAvL3RzbGludDpkaXNhYmxlLWxpbmVcbiAgbXVsdGk6IHRydWVcbn07XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1ttd2xGbGF0cGlja3JdJyxcbiAgcHJvdmlkZXJzOiBbRkxBVFBJQ0tSX0NPTlRST0xfVkFMVUVfQUNDRVNTT1JdLFxuICBob3N0OiB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbGluZSB1c2UtaG9zdC1wcm9wZXJ0eS1kZWNvcmF0b3JcbiAgICAnKGJsdXIpJzogJ29uVG91Y2hlZEZuKCknXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgRmxhdHBpY2tyRGlyZWN0aXZlXG4gIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgLyoqXG4gICAqIEV4YWN0bHkgdGhlIHNhbWUgYXMgZGF0ZSBmb3JtYXQsIGJ1dCBmb3IgdGhlIGFsdElucHV0IGZpZWxkLlxuICAgKi9cbiAgQElucHV0KCkgYWx0Rm9ybWF0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFx0U2hvdyB0aGUgdXNlciBhIHJlYWRhYmxlIGRhdGUgKGFzIHBlciBhbHRGb3JtYXQpLCBidXQgcmV0dXJuIHNvbWV0aGluZyB0b3RhbGx5IGRpZmZlcmVudCB0byB0aGUgc2VydmVyLlxuICAgKi9cbiAgQElucHV0KCkgYWx0SW5wdXQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoaXMgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW5wdXQgZWxlbWVudCBjcmVhdGVkIGJ5IHRoZSBhbHRJbnB1dCBvcHRpb24uXG4gICAqIE5vdGUgdGhhdCBgYWx0SW5wdXRgIGFscmVhZHkgaW5oZXJpdHMgY2xhc3NlcyBmcm9tIHRoZSBvcmlnaW5hbCBpbnB1dC5cbiAgICovXG4gIEBJbnB1dCgpIGFsdElucHV0Q2xhc3M6IHN0cmluZztcblxuICAvKipcbiAgICogQWxsb3dzIHRoZSB1c2VyIHRvIGVudGVyIGEgZGF0ZSBkaXJlY3RseSBpbnB1dCB0aGUgaW5wdXQgZmllbGQuIEJ5IGRlZmF1bHQsIGRpcmVjdCBlbnRyeSBpcyBkaXNhYmxlZC5cbiAgICovXG4gIEBJbnB1dCgpIGFsbG93SW5wdXQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEluc3RlYWQgb2YgYGJvZHlgLCBhcHBlbmRzIHRoZSBjYWxlbmRhciB0byB0aGUgc3BlY2lmaWVkIG5vZGUgaW5zdGVhZC5cbiAgICovXG4gIEBJbnB1dCgpIGFwcGVuZFRvOiBIVE1MRWxlbWVudDtcblxuICAvKipcbiAgICogRGVmaW5lcyBob3cgdGhlIGRhdGUgd2lsbCBiZSBmb3JtYXR0ZWQgaW4gdGhlIGFyaWEtbGFiZWwgZm9yIGNhbGVuZGFyIGRheXMsIHVzaW5nIHRoZSBzYW1lIHRva2VucyBhcyBkYXRlRm9ybWF0LiBJZiB5b3UgY2hhbmdlIHRoaXMsIHlvdSBzaG91bGQgY2hvb3NlIGEgdmFsdWUgdGhhdCB3aWxsIG1ha2Ugc2Vuc2UgaWYgYSBzY3JlZW4gcmVhZGVyIHJlYWRzIGl0IG91dCBsb3VkLlxuICAgKi9cbiAgQElucHV0KCkgYXJpYURhdGVGb3JtYXQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgY2xpY2tpbmcgb24gdGhlIGlucHV0IHNob3VsZCBvcGVuIHRoZSBwaWNrZXIuXG4gICAqIFlvdSBjb3VsZCBkaXNhYmxlIHRoaXMgaWYgeW91IHdpc2ggdG8gb3BlbiB0aGUgY2FsZW5kYXIgbWFudWFsbHkgYHdpdGgub3BlbigpYC5cbiAgICovXG4gIEBJbnB1dCgpIGNsaWNrT3BlbnM6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEEgc3RyaW5nIG9mIGNoYXJhY3RlcnMgd2hpY2ggYXJlIHVzZWQgdG8gZGVmaW5lIGhvdyB0aGUgZGF0ZSB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgaW5wdXQgYm94LlxuICAgKiBUaGUgc3VwcG9ydGVkIGNoYXJhY3RlcnMgYXJlIGRlZmluZWQgaW4gdGhlIHRhYmxlIGJlbG93LlxuICAgKi9cbiAgQElucHV0KCkgZGF0ZUZvcm1hdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsIHZhbHVlIG9mIHRoZSBob3VyIGVsZW1lbnQuXG4gICAqL1xuICBASW5wdXQoKSBkZWZhdWx0SG91cj86IG51bWJlcjtcbiAgLyoqXG4gICAqIEluaXRpYWwgdmFsdWUgb2YgdGhlIG1pbnV0ZSBlbGVtZW50LlxuICAgKi9cbiAgQElucHV0KCkgZGVmYXVsdE1pbnV0ZT86IG51bWJlcjtcblxuICAvKipcbiAgICogSW5pdGlhbCB2YWx1ZSBvZiB0aGUgc2Vjb25kcyBlbGVtZW50LlxuICAgKi9cbiAgQElucHV0KCkgZGVmYXVsdFNlY29uZHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jaG1sbi5naXRodWIuaW8vZmxhdHBpY2tyL2V4YW1wbGVzLyNkaXNhYmxpbmctc3BlY2lmaWMtZGF0ZXNcIj5kaXNhYmxpbmcgZGF0ZXM8L2E+LlxuICAgKi9cbiAgQElucHV0KCkgZGlzYWJsZTogRGlzYWJsZUVuYWJsZURhdGVbXTtcblxuICAvKipcbiAgICogU2V0IGRpc2FibGVNb2JpbGUgdG8gdHJ1ZSB0byBhbHdheXMgdXNlIHRoZSBub24tbmF0aXZlIHBpY2tlci5cbiAgICogQnkgZGVmYXVsdCwgRmxhdHBpY2tyIHV0aWxpemVzIG5hdGl2ZSBkYXRldGltZSB3aWRnZXRzIHVubGVzcyBjZXJ0YWluIG9wdGlvbnMgKGUuZy4gZGlzYWJsZSkgYXJlIHVzZWQuXG4gICAqL1xuICBASW5wdXQoKSBkaXNhYmxlTW9iaWxlOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTZWUgPGEgaHJlZj1cImh0dHBzOi8vY2htbG4uZ2l0aHViLmlvL2ZsYXRwaWNrci9leGFtcGxlcy8jZGlzYWJsaW5nLWFsbC1kYXRlcy1leGNlcHQtc2VsZWN0LWZld1wiPmVuYWJsaW5nIGRhdGVzPC9hPi5cbiAgICovXG4gIEBJbnB1dCgpIGVuYWJsZTogRGlzYWJsZUVuYWJsZURhdGVbXTtcblxuICAvKipcbiAgICogRW5hYmxlcyB0aW1lIHBpY2tlci5cbiAgICovXG4gIEBJbnB1dCgpIGVuYWJsZVRpbWU6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgc2Vjb25kcyBpbiB0aGUgdGltZSBwaWNrZXIuXG4gICAqL1xuICBASW5wdXQoKSBlbmFibGVTZWNvbmRzOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBbGxvd3MgdXNpbmcgYSBjdXN0b20gZGF0ZSBmb3JtYXR0aW5nIGZ1bmN0aW9uIGluc3RlYWQgb2YgdGhlIGJ1aWx0LWluIGhhbmRsaW5nIGZvciBkYXRlIGZvcm1hdHMgdXNpbmcgZGF0ZUZvcm1hdCwgYWx0Rm9ybWF0LCBldGMuXG4gICAqL1xuICBASW5wdXQoKSBmb3JtYXREYXRlPzogKHZhbHVlOiBhbnkpID0+IHN0cmluZztcblxuICAvKipcbiAgICogQWRqdXN0cyB0aGUgc3RlcCBmb3IgdGhlIGhvdXIgaW5wdXQgKGluY2wuIHNjcm9sbGluZykuXG4gICAqL1xuICBASW5wdXQoKSBob3VySW5jcmVtZW50OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIERpc3BsYXlzIHRoZSBjYWxlbmRhciBpbmxpbmUuXG4gICAqL1xuICBASW5wdXQoKSBpbmxpbmU6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGRhdGUgdGhhdCBhIHVzZXIgY2FuIHBpY2sgdG8gKGluY2x1c2l2ZSkuXG4gICAqL1xuICBASW5wdXQoKSBtYXhEYXRlOiBzdHJpbmcgfCBEYXRlO1xuXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBkYXRlIHRoYXQgYSB1c2VyIGNhbiBzdGFydCBwaWNraW5nIGZyb20gKGluY2x1c2l2ZSkuXG4gICAqL1xuICBASW5wdXQoKSBtaW5EYXRlOiBzdHJpbmcgfCBEYXRlO1xuXG4gIC8qKlxuICAgKiBBZGp1c3RzIHRoZSBzdGVwIGZvciB0aGUgbWludXRlIGlucHV0IChpbmNsLiBzY3JvbGxpbmcpLlxuICAgKi9cbiAgQElucHV0KCkgbWludXRlSW5jcmVtZW50OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhIHNpbmdsZSBkYXRlLCBtdWx0aXBsZSBkYXRlcyBvciBhIGRhdGUgcmFuZ2UuXG4gICAqL1xuICBASW5wdXQoKSBtb2RlOiAnc2luZ2xlJyB8ICdtdWx0aXBsZScgfCAncmFuZ2UnO1xuXG4gIC8qKlxuICAgKiBIVE1MIGZvciB0aGUgYXJyb3cgaWNvbiwgdXNlZCB0byBzd2l0Y2ggbW9udGhzLlxuICAgKi9cbiAgQElucHV0KCkgbmV4dEFycm93OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBkYXkgc2VsZWN0aW9uIGluIGNhbGVuZGFyLiBVc2UgaXQgYWxvbmcgd2l0aCBgZW5hYmxlVGltZWAgdG8gY3JlYXRlIGEgdGltZSBwaWNrZXIuXG4gICAqL1xuICBASW5wdXQoKSBub0NhbGVuZGFyOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgZGF0ZSBmb3IgJ3RvZGF5Jywgd2hpY2ggd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgXCJuZXcgRGF0ZSgpXCJcbiAgICovXG4gIEBJbnB1dCgpIG5vdz86IERhdGUgfCBzdHJpbmcgfCBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgZXhwZWN0cyBhIGRhdGUgc3RyaW5nIGFuZCBtdXN0IHJldHVybiBhIERhdGUgb2JqZWN0LlxuICAgKi9cbiAgQElucHV0KCkgcGFyc2VEYXRlOiAoc3RyOiBzdHJpbmcpID0+IERhdGU7XG5cbiAgLyoqXG4gICAqIEhUTUwgZm9yIHRoZSBsZWZ0IGFycm93IGljb24uXG4gICAqL1xuICBASW5wdXQoKSBwcmV2QXJyb3c6IHN0cmluZztcblxuICAvKipcbiAgICogU2hvdyB0aGUgbW9udGggdXNpbmcgdGhlIHNob3J0aGFuZCB2ZXJzaW9uIChpZSwgU2VwIGluc3RlYWQgb2YgU2VwdGVtYmVyKS5cbiAgICovXG4gIEBJbnB1dCgpIHNob3J0aGFuZEN1cnJlbnRNb250aDogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBtb250aHMgc2hvd24uXG4gICAqL1xuICBASW5wdXQoKSBzaG93TW9udGhzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIHRoZSBjYWxlbmRhciBpbnNpZGUgdGhlIHdyYXBwZXIgYW5kIG5leHQgdG8gdGhlIGlucHV0IGVsZW1lbnQuIChMZWF2ZSBgZmFsc2VgIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZykuXG4gICAqL1xuICBASW5wdXQoKSBzdGF0aWM6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERpc3BsYXlzIHRpbWUgcGlja2VyIGluIDI0IGhvdXIgbW9kZSB3aXRob3V0IEFNL1BNIHNlbGVjdGlvbiB3aGVuIGVuYWJsZWQuXG4gICAqL1xuICBASW5wdXQoKSB0aW1lMjRocjogYm9vbGVhbjtcblxuICAvKipcbiAgICogRW5hYmxlcyBkaXNwbGF5IG9mIHdlZWsgbnVtYmVycyBpbiBjYWxlbmRhci5cbiAgICovXG4gIEBJbnB1dCgpIHdlZWtOdW1iZXJzOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBZb3UgbWF5IG92ZXJyaWRlIHRoZSBmdW5jdGlvbiB0aGF0IGV4dHJhY3RzIHRoZSB3ZWVrIG51bWJlcnMgZnJvbSBhIERhdGUgYnkgc3VwcGx5aW5nIGEgZ2V0V2VlayBmdW5jdGlvbi5cbiAgICogSXQgdGFrZXMgaW4gYSBkYXRlIGFzIGEgcGFyYW1ldGVyIGFuZCBzaG91bGQgcmV0dXJuIGEgY29ycmVzcG9uZGluZyBzdHJpbmcgdGhhdCB5b3Ugd2FudCB0byBhcHBlYXIgbGVmdCBvZiBldmVyeSB3ZWVrLlxuICAgKi9cbiAgQElucHV0KCkgZ2V0V2VlazogKGRhdGU6IERhdGUpID0+IHN0cmluZztcblxuICAvKipcbiAgICogQ3VzdG9tIGVsZW1lbnRzIGFuZCBpbnB1dCBncm91cHMuXG4gICAqL1xuICBASW5wdXQoKSB3cmFwOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBwbHVnaW4gaW5zdGFuY2VzIHRvIHVzZS5cbiAgICovXG4gIEBJbnB1dCgpIHBsdWdpbnM6IGFueVtdO1xuXG4gIC8qKlxuICAgKiBUaGUgbG9jYWxlIG9iamVjdCBvciBzdHJpbmcgdG8gdXNlIGZvciB0aGUgbG9jYWxlLlxuICAgKi9cbiAgQElucHV0KCkgbG9jYWxlOiBvYmplY3QgfCBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEF1dG8gY29udmVydCB0aGUgbmdNb2RlbCB2YWx1ZSBmcm9tIGEgc3RyaW5nIHRvIGEgZGF0ZSAvIGFycmF5IG9mIGRhdGVzIC8gZnJvbSAtIHRvIGRhdGUgb2JqZWN0IGRlcGVuZGluZyBvbiB0aGUgYG1vZGVgXG4gICAqL1xuICBASW5wdXQoKSBjb252ZXJ0TW9kZWxWYWx1ZTogYm9vbGVhbjtcblxuICAvKipcbiAgICogR2V0cyB0cmlnZ2VyZWQgb25jZSB0aGUgY2FsZW5kYXIgaXMgaW4gYSByZWFkeSBzdGF0ZVxuICAgKi9cbiAgQE91dHB1dCgpXG4gIGZsYXRwaWNrclJlYWR5OiBFdmVudEVtaXR0ZXI8RmxhdFBpY2tyT3V0cHV0T3B0aW9ucz4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEdldHMgdHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIGRhdGUsIG9yIGNoYW5nZXMgdGhlIHRpbWUgb24gYSBzZWxlY3RlZCBkYXRlLlxuICAgKi9cbiAgQE91dHB1dCgpXG4gIGZsYXRwaWNrckNoYW5nZTogRXZlbnRFbWl0dGVyPEZsYXRQaWNrck91dHB1dE9wdGlvbnM+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRyaWdnZXJlZCB3aGVuIHRoZSBpbnB1dCB2YWx1ZSBpcyB1cGRhdGVkIHdpdGggYSBuZXcgZGF0ZSBzdHJpbmcuXG4gICAqL1xuICBAT3V0cHV0KClcbiAgZmxhdHBpY2tyVmFsdWVVcGRhdGU6IEV2ZW50RW1pdHRlcjxcbiAgICBGbGF0UGlja3JPdXRwdXRPcHRpb25zXG4gID4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEdldHMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNhbGVuZGFyIGlzIG9wZW5lZC5cbiAgICovXG4gIEBPdXRwdXQoKVxuICBmbGF0cGlja3JPcGVuOiBFdmVudEVtaXR0ZXI8RmxhdFBpY2tyT3V0cHV0T3B0aW9ucz4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEdldHMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNhbGVuZGFyIGlzIGNsb3NlZC5cbiAgICovXG4gIEBPdXRwdXQoKVxuICBmbGF0cGlja3JDbG9zZTogRXZlbnRFbWl0dGVyPEZsYXRQaWNrck91dHB1dE9wdGlvbnM+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRyaWdnZXJlZCB3aGVuIHRoZSBtb250aCBpcyBjaGFuZ2VkLCBlaXRoZXIgYnkgdGhlIHVzZXIgb3IgcHJvZ3JhbW1hdGljYWxseS5cbiAgICovXG4gIEBPdXRwdXQoKVxuICBmbGF0cGlja3JNb250aENoYW5nZTogRXZlbnRFbWl0dGVyPFxuICAgIEZsYXRQaWNrck91dHB1dE9wdGlvbnNcbiAgPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogR2V0cyB0cmlnZ2VyZWQgd2hlbiB0aGUgeWVhciBpcyBjaGFuZ2VkLCBlaXRoZXIgYnkgdGhlIHVzZXIgb3IgcHJvZ3JhbW1hdGljYWxseS5cbiAgICovXG4gIEBPdXRwdXQoKVxuICBmbGF0cGlja3JZZWFyQ2hhbmdlOiBFdmVudEVtaXR0ZXI8XG4gICAgRmxhdFBpY2tyT3V0cHV0T3B0aW9uc1xuICA+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBUYWtlIGZ1bGwgY29udHJvbCBvZiBldmVyeSBkYXRlIGNlbGwgd2l0aCB0aGlzIG91dHB1dFxuICAgKi9cbiAgQE91dHB1dCgpXG4gIGZsYXRwaWNrckRheUNyZWF0ZTogRXZlbnRFbWl0dGVyPFxuICAgIEZsYXRQaWNrckRheUNyZWF0ZU91dHB1dE9wdGlvbnNcbiAgPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBwcml2YXRlIGluc3RhbmNlOiBmbGF0cGlja3IuSW5zdGFuY2U7XG4gIHByaXZhdGUgaXNEaXNhYmxlZCA9IGZhbHNlO1xuICBwcml2YXRlIGluaXRpYWxWYWx1ZTogYW55O1xuXG4gIG9uQ2hhbmdlRm46ICh2YWx1ZTogYW55KSA9PiB2b2lkID0gKCkgPT4ge307IC8vIHRzbGludDpkaXNhYmxlLWxpbmVcblxuICBvblRvdWNoZWRGbiA9ICgpID0+IHt9O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWxtOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgZGVmYXVsdHM6IEZsYXRwaWNrckRlZmF1bHRzLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMlxuICApIHt9XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIGNvbnN0IG9wdGlvbnM6IGFueSA9IHtcbiAgICAgIGFsdEZvcm1hdDogdGhpcy5hbHRGb3JtYXQsXG4gICAgICBhbHRJbnB1dDogdGhpcy5hbHRJbnB1dCxcbiAgICAgIGFsdElucHV0Q2xhc3M6IHRoaXMuYWx0SW5wdXRDbGFzcyxcbiAgICAgIGFsbG93SW5wdXQ6IHRoaXMuYWxsb3dJbnB1dCxcbiAgICAgIGFwcGVuZFRvOiB0aGlzLmFwcGVuZFRvLFxuICAgICAgYXJpYURhdGVGb3JtYXQ6IHRoaXMuYXJpYURhdGVGb3JtYXQsXG4gICAgICBjbGlja09wZW5zOiB0aGlzLmNsaWNrT3BlbnMsXG4gICAgICBkYXRlRm9ybWF0OiB0aGlzLmRhdGVGb3JtYXQsXG4gICAgICBkZWZhdWx0SG91cjogdGhpcy5kZWZhdWx0SG91cixcbiAgICAgIGRlZmF1bHRNaW51dGU6IHRoaXMuZGVmYXVsdE1pbnV0ZSxcbiAgICAgIGRlZmF1bHRTZWNvbmRzOiB0aGlzLmRlZmF1bHRTZWNvbmRzLFxuICAgICAgZGlzYWJsZTogdGhpcy5kaXNhYmxlLFxuICAgICAgZGlzYWJsZU1vYmlsZTogdGhpcy5kaXNhYmxlTW9iaWxlLFxuICAgICAgZW5hYmxlOiB0aGlzLmVuYWJsZSxcbiAgICAgIGVuYWJsZVRpbWU6IHRoaXMuZW5hYmxlVGltZSxcbiAgICAgIGVuYWJsZVNlY29uZHM6IHRoaXMuZW5hYmxlU2Vjb25kcyxcbiAgICAgIGZvcm1hdERhdGU6IHRoaXMuZm9ybWF0RGF0ZSxcbiAgICAgIGhvdXJJbmNyZW1lbnQ6IHRoaXMuaG91ckluY3JlbWVudCxcbiAgICAgIGRlZmF1bHREYXRlOiB0aGlzLmluaXRpYWxWYWx1ZSxcbiAgICAgIGlubGluZTogdGhpcy5pbmxpbmUsXG4gICAgICBtYXhEYXRlOiB0aGlzLm1heERhdGUsXG4gICAgICBtaW5EYXRlOiB0aGlzLm1pbkRhdGUsXG4gICAgICBtaW51dGVJbmNyZW1lbnQ6IHRoaXMubWludXRlSW5jcmVtZW50LFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgbmV4dEFycm93OiB0aGlzLm5leHRBcnJvdyxcbiAgICAgIG5vQ2FsZW5kYXI6IHRoaXMubm9DYWxlbmRhcixcbiAgICAgIG5vdzogdGhpcy5ub3csXG4gICAgICBwYXJzZURhdGU6IHRoaXMucGFyc2VEYXRlLFxuICAgICAgcHJldkFycm93OiB0aGlzLnByZXZBcnJvdyxcbiAgICAgIHNob3J0aGFuZEN1cnJlbnRNb250aDogdGhpcy5zaG9ydGhhbmRDdXJyZW50TW9udGgsXG4gICAgICBzaG93TW9udGhzOiB0aGlzLnNob3dNb250aHMsXG4gICAgICBzdGF0aWM6IHRoaXMuc3RhdGljLFxuICAgICAgdGltZTI0aHI6IHRoaXMudGltZTI0aHIsXG4gICAgICB3ZWVrTnVtYmVyczogdGhpcy53ZWVrTnVtYmVycyxcbiAgICAgIGdldFdlZWs6IHRoaXMuZ2V0V2VlayxcbiAgICAgIHdyYXA6IHRoaXMud3JhcCxcbiAgICAgIHBsdWdpbnM6IHRoaXMucGx1Z2lucyxcbiAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGUsXG4gICAgICBvbkNoYW5nZTogKHNlbGVjdGVkRGF0ZXM6IERhdGVbXSwgZGF0ZVN0cmluZzogc3RyaW5nLCBpbnN0YW5jZTogYW55KSA9PiB7XG4gICAgICAgIHRoaXMuZmxhdHBpY2tyQ2hhbmdlLmVtaXQoeyBzZWxlY3RlZERhdGVzLCBkYXRlU3RyaW5nLCBpbnN0YW5jZSB9KTtcbiAgICAgIH0sXG4gICAgICBvbk9wZW46IChzZWxlY3RlZERhdGVzOiBEYXRlW10sIGRhdGVTdHJpbmc6IHN0cmluZywgaW5zdGFuY2U6IGFueSkgPT4ge1xuICAgICAgICB0aGlzLmZsYXRwaWNrck9wZW4uZW1pdCh7IHNlbGVjdGVkRGF0ZXMsIGRhdGVTdHJpbmcsIGluc3RhbmNlIH0pO1xuICAgICAgfSxcbiAgICAgIG9uQ2xvc2U6IChzZWxlY3RlZERhdGVzOiBEYXRlW10sIGRhdGVTdHJpbmc6IHN0cmluZywgaW5zdGFuY2U6IGFueSkgPT4ge1xuICAgICAgICB0aGlzLmZsYXRwaWNrckNsb3NlLmVtaXQoeyBzZWxlY3RlZERhdGVzLCBkYXRlU3RyaW5nLCBpbnN0YW5jZSB9KTtcbiAgICAgIH0sXG4gICAgICBvbk1vbnRoQ2hhbmdlOiAoXG4gICAgICAgIHNlbGVjdGVkRGF0ZXM6IERhdGVbXSxcbiAgICAgICAgZGF0ZVN0cmluZzogc3RyaW5nLFxuICAgICAgICBpbnN0YW5jZTogYW55XG4gICAgICApID0+IHtcbiAgICAgICAgdGhpcy5mbGF0cGlja3JNb250aENoYW5nZS5lbWl0KHsgc2VsZWN0ZWREYXRlcywgZGF0ZVN0cmluZywgaW5zdGFuY2UgfSk7XG4gICAgICB9LFxuICAgICAgb25ZZWFyQ2hhbmdlOiAoXG4gICAgICAgIHNlbGVjdGVkRGF0ZXM6IERhdGVbXSxcbiAgICAgICAgZGF0ZVN0cmluZzogc3RyaW5nLFxuICAgICAgICBpbnN0YW5jZTogYW55XG4gICAgICApID0+IHtcbiAgICAgICAgdGhpcy5mbGF0cGlja3JZZWFyQ2hhbmdlLmVtaXQoeyBzZWxlY3RlZERhdGVzLCBkYXRlU3RyaW5nLCBpbnN0YW5jZSB9KTtcbiAgICAgIH0sXG4gICAgICBvblJlYWR5OiAoc2VsZWN0ZWREYXRlczogRGF0ZVtdLCBkYXRlU3RyaW5nOiBzdHJpbmcsIGluc3RhbmNlOiBhbnkpID0+IHtcbiAgICAgICAgdGhpcy5mbGF0cGlja3JSZWFkeS5lbWl0KHsgc2VsZWN0ZWREYXRlcywgZGF0ZVN0cmluZywgaW5zdGFuY2UgfSk7XG4gICAgICB9LFxuICAgICAgb25WYWx1ZVVwZGF0ZTogKFxuICAgICAgICBzZWxlY3RlZERhdGVzOiBEYXRlW10sXG4gICAgICAgIGRhdGVTdHJpbmc6IHN0cmluZyxcbiAgICAgICAgaW5zdGFuY2U6IGFueVxuICAgICAgKSA9PiB7XG4gICAgICAgIHRoaXMuZmxhdHBpY2tyVmFsdWVVcGRhdGUuZW1pdCh7IHNlbGVjdGVkRGF0ZXMsIGRhdGVTdHJpbmcsIGluc3RhbmNlIH0pO1xuICAgICAgfSxcbiAgICAgIG9uRGF5Q3JlYXRlOiAoXG4gICAgICAgIHNlbGVjdGVkRGF0ZXM6IERhdGVbXSxcbiAgICAgICAgZGF0ZVN0cmluZzogc3RyaW5nLFxuICAgICAgICBpbnN0YW5jZTogYW55LFxuICAgICAgICBkYXlFbGVtZW50OiBIVE1MRWxlbWVudFxuICAgICAgKSA9PiB7XG4gICAgICAgIHRoaXMuZmxhdHBpY2tyRGF5Q3JlYXRlLmVtaXQoe1xuICAgICAgICAgIHNlbGVjdGVkRGF0ZXMsXG4gICAgICAgICAgZGF0ZVN0cmluZyxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBkYXlFbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9uc1trZXldID0gKHRoaXMuZGVmYXVsdHMgYXMgYW55KVtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG9wdGlvbnMudGltZV8yNGhyID0gb3B0aW9ucy50aW1lMjRocjtcbiAgICB0aGlzLmluc3RhbmNlID0gZmxhdHBpY2tyKFxuICAgICAgdGhpcy5lbG0ubmF0aXZlRWxlbWVudCxcbiAgICAgIG9wdGlvbnNcbiAgICApIGFzIGZsYXRwaWNrci5JbnN0YW5jZTtcbiAgICB0aGlzLnNldERpc2FibGVkU3RhdGUodGhpcy5pc0Rpc2FibGVkKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgT2JqZWN0LmtleXMoY2hhbmdlcykuZm9yRWFjaChpbnB1dEtleSA9PiB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0KGlucHV0S2V5IGFzIGFueSwgKHRoaXMgYXMgYW55KVtpbnB1dEtleV0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5pbnN0YW5jZS5kZXN0cm95KCk7XG4gIH1cblxuICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICBsZXQgY29udmVydGVkVmFsdWU6IGFueSA9IHZhbHVlO1xuICAgIGlmICh0aGlzLmNvbnZlcnRNb2RlbFZhbHVlICYmIHRoaXMubW9kZSA9PT0gJ3JhbmdlJyAmJiB2YWx1ZSkge1xuICAgICAgY29udmVydGVkVmFsdWUgPSBbdmFsdWUuZnJvbSwgdmFsdWUudG9dO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICB0aGlzLmluc3RhbmNlLnNldERhdGUoY29udmVydGVkVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmbGF0cGlja3IgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgeWV0LCBzdG9yZSB0aGUgdmFsdWUgZm9yIGxhdGVyIHVzZVxuICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSBjb252ZXJ0ZWRWYWx1ZTtcbiAgICB9XG4gIH1cblxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlRm4gPSBmbjtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblRvdWNoZWRGbiA9IGZuO1xuICB9XG5cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5pc0Rpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgaWYgKHRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuaW5zdGFuY2UuX2lucHV0LCAnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuaW5zdGFuY2UuX2lucHV0LCAnZGlzYWJsZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdpbnB1dCcpXG4gIGlucHV0Q2hhbmdlZCgpOiB2b2lkIHtcbiAgICBjb25zdCB2YWx1ZTogc3RyaW5nID0gdGhpcy5lbG0ubmF0aXZlRWxlbWVudC52YWx1ZTtcbiAgICBpZiAodGhpcy5jb252ZXJ0TW9kZWxWYWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICBjYXNlICdtdWx0aXBsZSc6XG4gICAgICAgICAgY29uc3QgZGF0ZXM6IERhdGVbXSA9IHZhbHVlXG4gICAgICAgICAgICAuc3BsaXQoJzsgJylcbiAgICAgICAgICAgIC5tYXAoc3RyID0+XG4gICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UucGFyc2VEYXRlKFxuICAgICAgICAgICAgICAgIHN0cixcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLmNvbmZpZy5kYXRlRm9ybWF0LFxuICAgICAgICAgICAgICAgICF0aGlzLmluc3RhbmNlLmNvbmZpZy5lbmFibGVUaW1lXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5vbkNoYW5nZUZuKGRhdGVzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgICAgY29uc3QgW2Zyb20sIHRvXSA9IHZhbHVlXG4gICAgICAgICAgICAuc3BsaXQodGhpcy5pbnN0YW5jZS5sMTBuLnJhbmdlU2VwYXJhdG9yKVxuICAgICAgICAgICAgLm1hcChzdHIgPT5cbiAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5wYXJzZURhdGUoXG4gICAgICAgICAgICAgICAgc3RyLFxuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuY29uZmlnLmRhdGVGb3JtYXQsXG4gICAgICAgICAgICAgICAgIXRoaXMuaW5zdGFuY2UuY29uZmlnLmVuYWJsZVRpbWVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLm9uQ2hhbmdlRm4oeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMub25DaGFuZ2VGbihcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UucGFyc2VEYXRlKFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5jb25maWcuZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgICAgIXRoaXMuaW5zdGFuY2UuY29uZmlnLmVuYWJsZVRpbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlRm4odmFsdWUpO1xuICAgIH1cbiAgfVxufVxuIl19